CC = g++
CFLAGS = -Wall -g -std=c++11
LDFLAGS = -pthread
STATICFLAG = -static
GTESTLDFLAGS = -lgtest -lgtest_main -lgmock
OBJDIR = obj
SRCDIR = src
BINDIR = bin
INTEGRATIONTESTDIR = integration_tests
TARGET = bin/toy_robot
STATICTARGET = bin/toy_robot_static
TEST = bin/toy_robot_test
INTEGRATIONTEST = bin/toy_robot_integration_test

SRCS := $(shell find $(SRCDIR) -type f \( -iname "*.cpp" ! -iname "*_test.cpp" ! -iname "main.cpp" \))
OBJS = $(patsubst $(SRCDIR)/%.cpp,$(OBJDIR)/%.o,$(SRCS))
DEPS = $(OBJS:%.o=%.d)

TESTSRCS := $(shell find $(SRCDIR) -type f -iname "*_test.cpp")
TESTOBJS = $(patsubst $(SRCDIR)/%.cpp,$(OBJDIR)/%.o,$(TESTSRCS))
TESTDEPS = $(TESTOBJS:%.o=%.d)

INTEGRATIONTESTSRCS := $(shell find $(INTEGRATIONTESTDIR) -type f -iname "*_test.cpp")
INTEGRATIONTESTOBJS = $(patsubst $(INTEGRATIONTESTDIR)/%.cpp,$(OBJDIR)/$(INTEGRATIONTESTDIR)/%.o,$(INTEGRATIONTESTSRCS))
INTEGRATIONTESTDEPS = $(INTEGRATIONTESTOBJS:%.o=%.d)

all: build test integration-test

# Include object dependencies as generated by gcc
-include $(DEPS)
-include $(TESTDEPS)
-include $(INTEGRATIONTESTDEPS)

.PHONY: build
build: $(TARGET)

# The static build is used by the docker image to be able to run without requiring libraries locally
.PHONY: build-static
build-static: $(STATICTARGET)

.PHONY: run
run: $(TARGET)
	./$(TARGET)

.PHONY: test
test: $(TEST)
	./$(TEST)

.PHONY: integration-test
integration-test: build $(INTEGRATIONTEST)
	./$(INTEGRATIONTEST)

$(TARGET): $(OBJS) $(OBJDIR)/main.o
	@mkdir -p $(@D)
	$(CC) $(CFLAGS) $(LDFLAGS) -o $(TARGET) $(OBJS) $(OBJDIR)/main.o

$(STATICTARGET): $(OBJS) $(OBJDIR)/main.o
	@mkdir -p $(@D)
	$(CC) $(CFLAGS) $(LDFLAGS) $(STATICFLAG) -o $(STATICTARGET) $(OBJS) $(OBJDIR)/main.o

$(TEST): $(OBJS) $(TESTOBJS)
	@mkdir -p $(@D)
	$(CC) $(CFLAGS) $(LDFLAGS) -o $(TEST) $(OBJS) $(TESTOBJS) $(GTESTLDFLAGS)

$(INTEGRATIONTEST): $(INTEGRATIONTESTOBJS)
	@mkdir -p $(@D)
	$(CC) $(CFLAGS) $(LDFLAGS) -o $(INTEGRATIONTEST) $(INTEGRATIONTESTOBJS) $(GTESTLDFLAGS)

$(OBJDIR)/$(INTEGRATIONTESTDIR)/%.o: $(INTEGRATIONTESTDIR)/%.cpp
	@mkdir -p $(@D)
	$(CC) $(CFLAGS) -MMD -c -o $@ $<

$(OBJDIR)/%.o: $(SRCDIR)/%.cpp
	@mkdir -p $(@D)
	$(CC) $(CFLAGS) -MMD -c -o $@ $<

# Docker will generate errors if the container or image don't exist, so these errors are ignored
.PHONY: clean
clean:
	rm -rf $(OBJDIR) $(BINDIR)
	-docker rm $(docker ps -a -q --filter ancestor=andrew-j-armstrong/toyrobot)
	-docker rmi andrew-j-armstrong/toyrobot

# Ubuntu setup uses apt to install GTest & GMock
.PHONY: ubuntu-setup
ubuntu-setup: ubuntu-libgtest-dev ubuntu-libgmock-dev

.PHONY: ubuntu-libgtest-dev
ubuntu-libgtest-dev:
	apt install -y libgtest-dev

.PHONY: ubuntu-libgmock-dev
ubuntu-libgmock-dev:
	apt install -y libgmock-dev

# Alpine setup uses apk to install GTest & GMock
.PHONY: alpine-setup
alpine-setup: alpine-gtest-dev alpine-gmock

.PHONY: alpine-gtest-dev
alpine-gtest-dev:
	apk add gtest-dev

.PHONY: alpine-gmock
alpine-gmock:
	apk add gmock

# Docker builds the image and then runs it interactively
.PHONY: docker
docker: docker-build docker-run

.PHONY: docker-build
docker-build:
	docker build -t andrew-j-armstrong/toyrobot .

.PHONY: docker-run
docker-run:
	docker run -it --rm andrew-j-armstrong/toyrobot

